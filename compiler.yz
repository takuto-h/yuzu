
open YzPervasives
open Printf

type t:
  inf : Inf.t
  dummy : unit

var initial_buffer_size = 256
var basic_offset = 2

def create(): {
  inf = Inf.create();
  dummy = ();
}

def compile_file(compiler, fname_in):
  var fname_out = try:
    sprintf("%s.ml", Filename.chop_extension(fname_in))
  with:
    case Invalid_argument(_):
      sprintf("%s.ml", fname_in)
  with_open_in(fname_in)^(chan_in):
  with_open_out(fname_out)^(chan_out):
    var strm = Stream.of_channel(chan_in)
    var src = Source.create(true, fname_in, strm)
    var lexer = Lexer.create(src)
    var parser = Parser.create(lexer)
    var trans = Trans.create(basic_offset)
    try:
      def loop(compiler):
        match Parser.parse(parser):
          case None:
            Some(compiler)
          case Some(top):
            var result = Trans.translate_top(trans, top)
            fprintf(chan_out, "%s\n", result)
            loop(compiler)
      loop(compiler)
    with:
      case Failure(message):
        eprintf("%s", message)
        flush(stderr)
        None

def compile_string(compiler, fname_in, str):
  var decls = Buffer.create(initial_buffer_size)
  var output = Buffer.create(initial_buffer_size)
  var strm = Stream.of_string(str)
  var src = Source.create(false, fname_in, strm)
  var lexer = Lexer.create(src)
  var parser = Parser.create(lexer)
  var trans = Trans.create(basic_offset)
  try:
    def loop(compiler):
      match Parser.parse(parser):
        case None:
          Some(compiler, Buffer.contents(decls), Buffer.contents(output))
        case Some(top):
          var (inf, decl) = Inf.infer_top(compiler.inf, top)
          Buffer.add_string(decls, Decl.show(decl))
          var result = Trans.translate_top(trans, top)
          Buffer.add_string(output, result)
          loop(compiler.{inf = inf})
    loop(compiler)
  with:
    case Failure(message):
      eprintf("%s", message)
      flush(stderr)
      None

def compile_files(compiler, fnames):
  match fnames:
    case []:
      Some(compiler)
    case fname_in::fnames:
      match compile_file(compiler, fname_in):
        case None:
          None
        case Some(compiler):
          compile_files(compiler, fnames)

def read(buf):
  printf("> ")
  var line = read_line()
  if line = "":
    Buffer.contents(buf)
  else:
    Buffer.add_string(buf, sprintf("%s\n", line))
    read(buf)

def interactive(compiler):
  try:
    var str = read(Buffer.create(initial_buffer_size))
    match compile_string(compiler, "<interactive>", str):
      case None:
        interactive(compiler)
      case Some(compiler, decls, output):
        printf("decls:\n%s", decls)
        printf("output:\n%s", output)
        interactive(compiler)
  with:
    case End_of_file:
      compiler

def load_iface_file(compiler, fname_in):
  var mod_name = String.capitalize(
    try{
      Filename.chop_extension(fname_in)
    }with{
      case Invalid_argument(_){ fname_in }
    }
  )
  with_open_in(fname_in)^(chan_in):
    var strm = Stream.of_channel(chan_in)
    var src = Source.create(true, fname_in, strm)
    var lexer = Lexer.create(src)
    var parser = Parser.create(lexer)
    try:
      def loop(compiler):
        match Parser.parse_decl(parser):
          case None:
            Some(compiler.{inf = Inf.leave_module(compiler.inf, mod_name)})
          case Some(decl):
            var inf = Inf.load_decl(compiler.inf, decl)
            loop(compiler.{inf = inf})
      loop(compiler)
    with:
      case Failure(message):
        eprintf("%s", message)
        flush(stderr)
        None
