
open Printf

module ValNameMap = Map.Make(ValName)

type require_argument = bool

type t:
  mods : list(Names.mod_name * Module.t)
  opens : list(Names.mod_name * Names.mod_path)
  asp : list(Names.val_name * Scheme.t)
  ctors : list(Names.ctor_name * (require_argument * Scheme.t))
  typectors : list(Names.typector_name * (Names.typector * int))
  let_level : int
  mod_name : Names.mod_name

var default_opens = [("Pervasives", [])]
  
def create(): {
  mods = [];
  opens = default_opens;
  asp = [];
  ctors = [];
  typectors = [];
  let_level = 0;
  mod_name = "Dummy";
}

def incr_let_level(inf): inf.{
  let_level = inf.let_level + 1;
}

var unit_type = Type.Con(["Pervasives"], "unit")
var int_type = Type.Con(["Pervasives"], "int")
var string_type = Type.Con(["Pervasives"], "string")
var char_type = Type.Con(["Pervasives"], "char")
var bool_type = Type.Con(["Pervasives"], "bool")

def unbound_variable(pos, path):
  Pos.show_error(pos, sprintf("unbound variable: %s\n", Names.show_val_path(path)))

def unbound_constructor(pos, ctor):
  Pos.show_error(pos, sprintf("unbound constructor: %s\n", Names.show_ctor(ctor)))

def unbound_type_constructor(pos, typector):
  Pos.show_error(pos, sprintf("unbound type constructor: %s\n", Names.show_typector(typector)))

def invalid_application(pos, fun_type, arg_type, t1, t2):
  var shower = Type.create_shower(0)
  sprintf(
    "%s%s%s",
    Pos.show_error(
      pos,
      sprintf(
        "invalid application\n%s%s",
        sprintf("function type: %s\n", Type.show(shower, fun_type)),
        sprintf("argument type: %s\n", Type.show(shower, arg_type)),
      ),
    ),
    Type.show_origin(shower, "function type", t1),
    Type.show_origin(shower, "argument type", t2),
  )

def wrong_number_of_arguments(pos, got, req):
  Pos.show_error(pos, sprintf("wrong number of arguments (%d for %d)\n", got, req))

def invalid_if_expr(pos, then_type, else_type, t1, t2):
  var shower = Type.create_shower(0)
  sprintf(
    "%s%s%s",
    Pos.show_error(
      pos,
      sprintf(
        "invalid if expression\n%s%s",
        sprintf("then-clause type: %s\n", Type.show(shower, then_type)),
        sprintf("else-clause type: %s\n", Type.show(shower, else_type)),
      ),
    ),
    Type.show_origin(shower, "then-clause type", t1),
    Type.show_origin(shower, "else-clause type", t2),
  )

def required(pos, req_type, got_type, t1, t2):
  var shower = Type.create_shower(0)
  sprintf(
    "%s%s%s",
    Pos.show_error(
      pos,
      sprintf(
        "'%s' required, but got '%s'\n",
        Type.show(shower, req_type), Type.show(shower, got_type)
      )
    ),
    Type.show_origin(shower, "required type", t1),
    Type.show_origin(shower, "got type", t2),
  )

def search_mods(search_mod, mods, mod_name, mod_path, name):
  var modl = List.assoc(mod_name, mods)
  search_mod(modl, mod_path, name)

def search_opens(search_mod, mods, opens, name):
  match opens:
    case []:
      raise(Not_found)
    case (mod_name, mod_path)::opens:
      try:
        search_mods(search_mod, mods, mod_name, mod_path, name)
      with:
        case Not_found:
          search_opens(search_mod, mods, opens, name)

def search_alist(search_mod, alist, inf, path):
  match path:
    case ([], name):
      try:
        List.assoc(name, alist)
      with:
        case Not_found:
          search_opens(search_mod, inf.mods, inf.opens, name)
    case (mod_name::mod_path, name):
      search_mods(search_mod, inf.mods, mod_name, mod_path, name)

def search_asp(inf, path):
  search_alist(Module.search_asp, inf.asp, inf, path)

def search_ctors(inf, ctor):
  search_alist(Module.search_ctors, inf.ctors, inf, ctor)

def search_typectors(inf, typector):
  search_alist(Module.search_typectors, inf.typectors, inf, typector)

def instantiate(let_level, {Scheme.gen_num;Scheme.body}):
  var type_vars = Array.init(gen_num)^(_): Type.make_var(let_level)
  def var_func(t, _, _):
    t
  def gen_func(t, n):
    Array.get(type_vars, n)
  Type.map(var_func, gen_func, body)

def infer_literal(lit):
  match lit:
    case Literal.Unit:
      unit_type
    case Literal.Int(_):
      int_type
    case Literal.String(_):
      string_type
    case Literal.Char(_):
      char_type
    case Literal.Bool(_):
      bool_type

def add_asp(inf, name):
  var t = Type.make_var(inf.let_level)
  var inf = inf.{asp = (name,Scheme.mono(t))::inf.asp}
  (inf, t)

def infer_pattern(inf, pat):
  match pat.Pattern.raw:
    case Pattern.Con(lit):
      (inf, Type.at(None, infer_literal(lit)), ValNameMap.empty)
    case Pattern.Var(name):
      var (inf, t) = add_asp(inf, name)
      (inf, t, ValNameMap.singleton(name, t))
    case Pattern.Tuple(pats):
      var init = (inf, [], ValNameMap.empty)
      var (inf, ts, map) = YzList.fold_right(pats, init)^(elem, (inf, ts, map1)):
        var (inf, t, map2) = infer_pattern(inf, elem)
        (inf, t::ts, ValNameMap.merge^(_){YzOption.or_}(map1, map2))
      (inf, Type.at(None, Type.Tuple(ts)), map)

def generalize(let_level, t):
  var alist_ref = ref([])
  def var_func(t, lv, ref):
    if lv > let_level:
      try:
        List.assq(ref, !alist_ref)
      with:
        case Not_found:
          var gen = Type.at(t.Type.pos, Type.Gen(List.length(!alist_ref)))
          alist_ref := (ref, gen)::!alist_ref
          gen
    else:
      t
  def gen_func(t, _):
    assert(false)
  Scheme.poly(List.length(!alist_ref), Type.map(var_func, gen_func, t))

def apply(let_level, pos, fun_type, arg_type):
  var ret_type = Type.make_var(let_level)
  try:
    Type.unify(fun_type, Type.at(None, Type.Fun(arg_type, ret_type)))
  with:
    case Type.Unification_error(t1, t2):
      failwith(invalid_application(pos, fun_type, arg_type, t1, t2))
  ret_type

rec:
  def infer_expr(inf, expr):
    match expr.Expr.raw:
      case Expr.Con(lit):
        Type.at(Some(expr.Expr.pos), infer_literal(lit))
      case Expr.Var(path):
        try:
          instantiate(inf.let_level, search_asp(inf, path))
        with:
          case Not_found:
            failwith(unbound_variable(expr.Expr.pos, path))
      case Expr.Abs(pat, body_expr):
        var (inf, pat_type, map) = infer_pattern(inf, pat)
        var body_type = infer_expr(inf, body_expr)
        Type.at(Some(expr.Expr.pos), Type.Fun(pat_type, body_type))
      case Expr.App(fun_expr, arg_expr):
        var fun_type = infer_expr(inf, fun_expr)
        var arg_type = infer_expr(inf, arg_expr)
        apply(inf.let_level, expr.Expr.pos, fun_type, arg_type)
      case Expr.Ctor(ctor, opt_arg_expr):
        try:
          match (search_ctors(inf, ctor), opt_arg_expr):
            case ((false, scm), None):
              instantiate(inf.let_level, scm)
            case ((false, scm), Some(arg_expr)):
              failwith(wrong_number_of_arguments(expr.Expr.pos, 1, 0))
            case ((true, scm), None):
              failwith(wrong_number_of_arguments(expr.Expr.pos, 0, 1))
            case ((true, scm), Some(arg_expr)):
              var arg_type = infer_expr(inf, arg_expr)
              apply(inf.let_level, expr.Expr.pos, instantiate(inf.let_level, scm), arg_type)
        with:
          case Not_found:
            failwith(unbound_constructor(expr.Expr.pos, ctor))
      case Expr.If(cond_expr, then_expr, else_expr):
        var cond_type = infer_expr(inf, cond_expr)
        var then_type = infer_expr(inf, then_expr)
        var else_type = infer_expr(inf, else_expr)
        require(cond_expr.Expr.pos, Type.at(None, bool_type), cond_type)
        try:
          Type.unify(then_type, else_type)
        with:
          case Type.Unification_error(t1, t2):
            failwith(invalid_if_expr(expr.Expr.pos, then_type, else_type, t1, t2))
        else_type
      case Expr.Tuple(exprs):
        Type.at(Some(expr.Expr.pos), Type.Tuple(List.map(infer_expr(inf), exprs)))
      case Expr.Or(lhs, rhs):
        var pos = expr.Expr.pos
        var or_op = Expr.at(pos, Expr.Var([], Names.Op("||")))
        var or_expr = Expr.at(pos, Expr.App(Expr.at(pos, Expr.App(or_op, lhs)), rhs))
        infer_expr(inf, or_expr)
      case Expr.And(lhs, rhs):
        var pos = expr.Expr.pos
        var and_op = Expr.at(pos, Expr.Var([], Names.Op("&&")))
        var and_expr = Expr.at(pos, Expr.App(Expr.at(pos, Expr.App(and_op, lhs)), rhs))
        infer_expr(inf, and_expr)
      case Expr.Seq(lhs, rhs):
        var lhs_type = infer_expr(inf, lhs)
        var rhs_type = infer_expr(inf, rhs)
        require(lhs.Expr.pos, Type.at(None, unit_type), lhs_type)
        rhs_type
      case Expr.LetVal(pat,val_expr,cont_expr):
        var val_type = infer_expr(inf, val_expr)
        var (inf, pat_type, map) = infer_pattern(inf, pat)
        require(val_expr.Expr.pos, pat_type, val_type)
        infer_expr(inf, cont_expr)
      case Expr.LetFun(defs, cont_expr):
        var let_level = inf.let_level
        var tmp_inf = incr_let_level(inf)
        var tmp_inf = YzList.fold_left(tmp_inf, defs)^(tmp_inf, (name, val_expr)):
          var (tmp_inf, t) = add_asp(tmp_inf, name)
          tmp_inf
        var inf = YzList.fold_left(inf, defs)^(inf, (name, val_expr)):
          var val_type = infer_expr(tmp_inf, val_expr)
          var scm = generalize(let_level, val_type)
          inf.{asp = (name, scm)::inf.asp}
        infer_expr(inf, cont_expr)

  def require(pos, req_type, got_type):
    try:
      Type.unify(req_type, got_type)
    with:
      case Type.Unification_error(t1, t2):
        failwith(required(pos, req_type, got_type, t1, t2))

def make_decls(map):
  List.rev(ValNameMap.fold^(name, t, acc){Decl.Val(name, Scheme.mono(t))::acc}(map, []))

def eval(inf, env_ref, type_expr):
  var t = match type_expr.TypeExpr.raw:
    case TypeExpr.Con(typector):
      try:
        var (typector, param_num) = search_typectors(inf, typector)
        if param_num = 0:
          Type.Con(typector)
        else:
          failwith(wrong_number_of_arguments(type_expr.TypeExpr.pos, 0, param_num))
      with:
        case Not_found:
         failwith(unbound_type_constructor(type_expr.TypeExpr.pos, typector))
    case TypeExpr.Var(name):
      try:
        List.assoc(name, !env_ref)
      with:
        case Not_found:
          var t = Type.make_var(inf.let_level).Type.raw
          env_ref := (name, t)::!env_ref
          t
    case TypeExpr.App(typector,ts):
      try:
        var (typector, param_num) = search_typectors(inf, typector)
        var arg_num = List.length(ts)
        if param_num = arg_num:
          Type.App(typector, List.map(eval(inf, env_ref), ts))
        else:
          failwith(wrong_number_of_arguments(type_expr.TypeExpr.pos, arg_num, param_num))
      with:
        case Not_found:
         failwith(unbound_type_constructor(type_expr.TypeExpr.pos, typector))
    case TypeExpr.Tuple(ts):
      Type.Tuple(List.map(eval(inf, env_ref), ts))
    case TypeExpr.Fun(t1, t2):
      var t10 = eval(inf, env_ref, t1)
      var t20 = eval(inf, env_ref, t2)
      Type.Fun(t10, t20)
  Type.at(Some(type_expr.TypeExpr.pos), t)

def load_type_info(inf, type_info):
  match type_info:
    case TypeInfo.Variant(ctor_decls):
      var let_level = inf.let_level
      var tmp_inf = incr_let_level(inf)
      YzList.fold_left(inf, ctor_decls)^(inf, (ctor_name, opt_param, ctor_type_expr)):
        var ctor_type = eval(tmp_inf, ref([]), ctor_type_expr)
        var ctor_scm = generalize(let_level, ctor_type)
        match opt_param:
          case None:
            inf.{ctors = (ctor_name, (false, ctor_scm))::inf.ctors}
          case Some(_):
            inf.{ctors = (ctor_name, (true, ctor_scm))::inf.ctors}

def infer_top(inf, top):
  match top.Top.raw:
    case Top.Expr(expr):
      (inf, [Decl.Val(Names.Id("_"), Scheme.mono(infer_expr(inf, expr)))])
    case Top.LetVal(pat,val_expr):
      var val_type = infer_expr(inf, val_expr)
      var (inf, pat_type, map) = infer_pattern(inf, pat)
      require(val_expr.Expr.pos, pat_type, val_type)
      (inf, make_decls(map))
    case Top.LetFun(defs):
      var let_level = inf.let_level
      var tmp_inf = incr_let_level(inf)
      var tmp_inf = YzList.fold_left(tmp_inf, defs)^(tmp_inf, (name, val_expr)):
        var (tmp_inf, t) = add_asp(tmp_inf, name)
        tmp_inf
      var (inf, decls) = YzList.fold_left((inf, []), defs)^((inf, decls), (name, val_expr)):
        var val_type = infer_expr(tmp_inf, val_expr)
        var scm = generalize(let_level, val_type)
        (inf.{asp = (name, scm)::inf.asp}, Decl.Val(name, scm)::decls)
      (inf, decls)
    case Top.Type((name,type_params,type_info)::defs):
      var typector = ([inf.mod_name], name)
      var param_num = List.length(type_params)
      var inf = inf.{typectors = (name, (typector, param_num))::inf.typectors}
      var inf = load_type_info(inf, type_info)
      (inf, [])

def load_decl(inf, decl):
  match decl:
    case DeclExpr.Val(name, type_expr):
      var scm = Scheme.mono(eval(inf, ref([]), type_expr))
      inf.{asp = (name, scm)::inf.asp}
    case DeclExpr.AbstrType(name, param_num):
      var typector = ([inf.mod_name], name)
      inf.{typectors = (name, (typector, param_num))::inf.typectors}
    case DeclExpr.ConcrType(name, param_num, type_info):
      var typector = ([inf.mod_name], name)
      var inf = inf.{typectors = (name, (typector, param_num))::inf.typectors}
      match type_info:
        case TypeInfo.Variant(ctor_decls):
          var let_level = inf.let_level
          var tmp_inf = incr_let_level(inf)
          YzList.fold_left(inf, ctor_decls)^(inf, (ctor_name, opt_param, ctor_type_expr)):
            var ctor_type = eval(tmp_inf, ref([]), ctor_type_expr)
            var ctor_scm = generalize(let_level, ctor_type)
            match opt_param:
              case None:
                inf.{ctors = (ctor_name, (false, ctor_scm))::inf.ctors}
              case Some(_):
                inf.{ctors = (ctor_name, (true, ctor_scm))::inf.ctors}

def enter_module(inf, mod_name):
  inf.{mod_name = mod_name}

def leave_module(inf, mod_name):
  var new_mod = Module.make([], inf.asp, inf.ctors, inf.typectors)
  {
    mods = (mod_name, new_mod)::inf.mods;
    opens = default_opens;
    asp = [];
    ctors = [];
    typectors = [];
    let_level = 0;
    mod_name = "Pervasives";
  }

//      
// assertions
//
var pos = Pos.make("<assertion>", 1, 0, 0, Pos.String("<assertion>"))
var mod_B = Module.make(
  [],
  [(Names.Id("b1"), Scheme.mono(Type.at(Some(pos),char_type)));
   (Names.Id("b2"), Scheme.mono(Type.at(Some(pos),int_type)));
  ],
  [],
  [],
)
var mod_A = Module.make(
  [("B", mod_B)],
  [(Names.Id("a1"), Scheme.mono(Type.at(Some(pos),int_type)));
   (Names.Id("a2"), Scheme.mono(Type.at(Some(pos),string_type)));
  ],
  [],
  [],
)
var mod_Pervasives = Module.make(
  [],
  [(Names.Op("+"),
    Scheme.mono(
      Type.at(Some(pos),Type.Fun(
        Type.at(Some(pos),int_type),
        Type.at(Some(pos),Type.Fun(
          Type.at(Some(pos),int_type),Type.at(Some(pos),int_type)))))));
  ],
  [],
  [],
)
var inf = {
  mods = [
    ("A", mod_A);
    ("Pervasives", mod_Pervasives);
  ];
  opens = [("Pervasives", [])];
  asp = [(Names.Id("ans"), Scheme.mono(Type.at(Some(pos),int_type)))];
  ctors = [];
  typectors = [];
  let_level = 0;
  mod_name = "Pervasives";
}
var shower = Type.create_shower(0)
var int_expr = Expr.at(pos, Expr.Con(Literal.Int(123)))
var string_expr = Expr.at(pos, Expr.Con(Literal.String("abc")))
var char_expr = Expr.at(pos, Expr.Con(Literal.Char("x")))
assert(Type.show(shower, infer_expr(inf, int_expr)) = "Pervasives.int")
assert(Type.show(shower, infer_expr(inf, string_expr)) = "Pervasives.string")
assert(Type.show(shower, infer_expr(inf, char_expr)) = "Pervasives.char")
var ans = Expr.at(pos, Expr.Var([], Names.Id("ans")))
var _A_a2 = Expr.at(pos, Expr.Var(["A"], Names.Id("a2")))
var _A_B_b1 = Expr.at(pos, Expr.Var(["A"; "B"], Names.Id("b1")))
assert(Type.show(shower, infer_expr(inf, ans)) = "Pervasives.int")
assert(Type.show(shower, infer_expr(inf, _A_a2)) = "Pervasives.string")
assert(Type.show(shower, infer_expr(inf, _A_B_b1)) = "Pervasives.char")
var app_expr = Expr.at(pos, Expr.App(int_expr, string_expr))
try:
  ignore(infer_expr(inf, app_expr))
with:
  case Failure(got):
    var req = sprintf(
      "%s%s%s%s%s%s%s%s",
      "<assertion>:1:0: error: invalid application\n",
      "function type: Pervasives.int\n",
      "argument type: Pervasives.string\n",
      "<assertion>\n",
      "^\n",
      "<assertion>:1:0: 'Pervasives.int' of function type\n",
      "<assertion>\n",
      "^\n",
    )
    assert(got = req)
var add = Expr.at(pos, Expr.Var([], Names.Op("+")))
var add_int = Expr.at(pos, Expr.App(add, int_expr))
var add_int_int = Expr.at(pos,Expr.App(add_int, int_expr))
assert(Type.show(shower, infer_expr(inf, add)) = "(Pervasives.int -> (Pervasives.int -> Pervasives.int))")
assert(Type.show(shower, infer_expr(inf, add_int)) = "(Pervasives.int -> Pervasives.int)")
assert(Type.show(shower, infer_expr(inf, add_int_int)) = "Pervasives.int")
