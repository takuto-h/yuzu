
open Printf

type t:
  mods : list(Names.mod_name * Module.t)
  asp : list(Names.val_name * Scheme.t)
  let_level : int
  
def create(): {
  mods = [];
  asp = [];
  let_level = 0;
}

var int_type = Type.Con([], "int")
var string_type = Type.Con([], "string")
var char_type = Type.Con([], "char")

def unbound_variable(pos, path):
  sprintf(
    "%s: error: unbound variable: %s\n",
    Pos.show(pos), Names.show_val_path(path)
  )

def find_asp(inf, path):
  match path:
    case ([], name):
      List.assoc(name, inf.asp)
    case (mod_name::mod_path, name):
      var modl = List.assoc(mod_name, inf.mods)
      Module.find_asp(modl, mod_path, name)

def instantiate(let_level, {Scheme.gen_num;Scheme.body}):
  var type_vars = Array.init(gen_num)^(_): Type.make_var(let_level)
  Type.map(body)^(n): Array.get(type_vars, n)

def infer_literal(lit):
  match lit:
    case Literal.Int(_):
      int_type
    case Literal.String(_):
      string_type
    case Literal.Char(_):
      char_type

def infer(inf, expr):
  match expr.Expr.raw:
    case Expr.Con(lit):
      infer_literal(lit)
    case Expr.Var(path):
      try:
        instantiate(inf.let_level, find_asp(inf, path))
      with:
        case Not_found:
          failwith(unbound_variable(expr.Expr.pos, path))
    case Expr.App(fun_expr, arg_expr):
      var fun_type = infer(inf, fun_expr)
      var arg_type = infer(inf, arg_expr)
      var ret_type = Type.make_var(inf.let_level)
      def occurs_check_error():
        failwith("")
      def unification_error(t1,t2):
        failwith("")
      Type.unify(
        fun_type, Type.Fun(arg_type, ret_type), occurs_check_error, unification_error
      )
      ret_type

//      
// assertions
//
var mod_B = Module.make(
  [],
  [(Names.Id("b1"), Scheme.mono(char_type)); (Names.Id("b2"), Scheme.mono(int_type))],
)
var mod_A = Module.make(
  [("B", mod_B)],
  [(Names.Id("a1"), Scheme.mono(int_type)); (Names.Id("a2"), Scheme.mono(string_type))],
)
var inf = {
  mods = [("A", mod_A)];
  asp = [(Names.Id("ans"), Scheme.mono(int_type))];
  let_level = 0;
}
var pos = Pos.make("<assertion>", 1, 0, 0)
var int_expr = Expr.at(pos, Expr.Con(Literal.Int(123)))
var string_expr = Expr.at(pos, Expr.Con(Literal.String("abc")))
var char_expr = Expr.at(pos, Expr.Con(Literal.Char("x")))
assert(infer(inf, int_expr) = int_type)
assert(infer(inf, string_expr) = string_type)
assert(infer(inf, char_expr) = char_type)
var ans = Expr.at(pos, Expr.Var([], Names.Id("ans")))
var _A_a2 = Expr.at(pos, Expr.Var(["A"], Names.Id("a2")))
var _A_B_b1 = Expr.at(pos, Expr.Var(["A"; "B"], Names.Id("b1")))
assert(infer(inf, ans) = int_type)
assert(infer(inf, _A_a2) = string_type)
assert(infer(inf, _A_B_b1) = char_type)
