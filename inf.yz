
open Printf

type t:
  mods : list(Names.mod_name * Module.t)
  opens : list(Names.mod_name * Names.mod_path)
  asp : list(Names.val_name * Scheme.t)
  let_level : int

var default_opens = [("Pervasives", [])]
  
def create(): {
  mods = [];
  opens = default_opens;
  asp = [];
  let_level = 0;
}

var int_type = Type.Con([], "int")
var string_type = Type.Con([], "string")
var char_type = Type.Con([], "char")

def unbound_variable(pos, path):
  sprintf(
    "%s: error: unbound variable: %s\n%s",
    Pos.show(pos), Names.show_val_path(path), Pos.show_source(pos)
  )

def invalid_application(pos, fun_type, arg_type, t1, t2):
  var shower = Type.create_shower(0)
  sprintf(
    "%s: error: invalid application\n%s%s%s%s%s", Pos.show(pos),
    sprintf("function type: %s\n", Type.show(shower, fun_type)),
    sprintf("argument type: %s\n", Type.show(shower, arg_type)),
    Pos.show_source(pos),
    Type.show_origin(shower, "function type", t1),
    Type.show_origin(shower, "argument type", t2),
  )

def find_mods(mods, mod_name, mod_path, name):
  var modl = List.assoc(mod_name, mods)
  Module.find_asp(modl, mod_path, name)

def find_opens(mods, opens, name):
  match opens:
    case []:
      raise(Not_found)
    case (mod_name, mod_path)::opens:
      try:
        find_mods(mods, mod_name, mod_path, name)
      with:
        case Not_found:
          find_opens(mods, opens, name)

def find_asp(inf, path):
  match path:
    case ([], name):
      try:
        List.assoc(name, inf.asp)
      with:
        case Not_found:
          find_opens(inf.mods, inf.opens, name)
    case (mod_name::mod_path, name):
      find_mods(inf.mods, mod_name, mod_path, name)

def instantiate(let_level, {Scheme.gen_num;Scheme.body}):
  var type_vars = Array.init(gen_num)^(_): Type.make_var(let_level)
  Type.map(Array.get(type_vars), body)

def infer_literal(lit):
  match lit:
    case Literal.Int(_):
      int_type
    case Literal.String(_):
      string_type
    case Literal.Char(_):
      char_type

def infer_pattern(inf, pat):
  match pat:
    case Pattern.Con(lit):
      (inf, Type.at(None, infer_literal(lit)))
    case Pattern.Var(name):
      var t = Type.make_var(inf.let_level)
      var inf = inf.{asp = (name,Scheme.mono(t))::inf.asp}
      (inf, t)
    case Pattern.Tuple(pats):
      var (inf, ts) = YzList.fold_right(pats, (inf, []))^(elem, (inf, ts)):
        var (inf, t) = infer_pattern(inf, elem)
        (inf, t::ts)
      (inf, Type.at(None, Type.Tuple(ts)))

def infer_expr(inf, expr):
  match expr.Expr.raw:
    case Expr.Con(lit):
      Type.at(Some(expr.Expr.pos), infer_literal(lit))
    case Expr.Var(path):
      try:
        instantiate(inf.let_level, find_asp(inf, path))
      with:
        case Not_found:
          failwith(unbound_variable(expr.Expr.pos, path))
    case Expr.App(fun_expr, arg_expr):
      var fun_type = infer_expr(inf, fun_expr)
      var arg_type = infer_expr(inf, arg_expr)
      var ret_type = Type.make_var(inf.let_level)
      try:
        Type.unify(fun_type, Type.at(None, Type.Fun(arg_type, ret_type)))
      with:
        case Type.Unification_error(t1, t2):
          failwith(invalid_application(expr.Expr.pos, fun_type, arg_type, t1, t2))
      ret_type
    case Expr.Abs(pat, body_expr):
      var (inf, pat_type) = infer_pattern(inf, pat)
      var body_type = infer_expr(inf, body_expr)
      Type.at(Some(expr.Expr.pos), Type.Fun(pat_type, body_type))

def infer_top(inf, top):
  match top.Top.raw:
    case Top.Expr(expr):
      (inf, Decl.Var(Names.Id("_"), Scheme.mono(infer_expr(inf, expr))))

def eval(inf, type_expr):
  var t = match type_expr.TypeExpr.raw:
    case TypeExpr.Con(typector):
      Type.Con(typector)
    case TypeExpr.App(typector,ts):
      Type.App(typector, List.map(eval(inf), ts))
    case TypeExpr.Tuple(ts):
      Type.Tuple(List.map(eval(inf), ts))
    case TypeExpr.Fun(t1, t2):
      Type.Fun(eval(inf, t1), eval(inf, t2))
  Type.at(Some(type_expr.TypeExpr.pos), t)

def load_decl(inf, decl):
  match decl:
    case DeclExpr.Var(name, type_expr):
      var scm = Scheme.mono(eval(inf, type_expr))
      inf.{asp = (name, scm)::inf.asp}

def leave_module(inf, mod_name):
  var new_mod = Module.make([], inf.asp)
  {
    mods = (mod_name, new_mod)::inf.mods;
    opens = default_opens;
    asp = [];
    let_level = 0;
  }

//      
// assertions
//
var pos = Pos.make("<assertion>", 1, 0, 0, Pos.String("<assertion>"))
var mod_B = Module.make(
  [],
  [(Names.Id("b1"), Scheme.mono(Type.at(Some(pos),char_type)));
   (Names.Id("b2"), Scheme.mono(Type.at(Some(pos),int_type)));
  ],
)
var mod_A = Module.make(
  [("B", mod_B)],
  [(Names.Id("a1"), Scheme.mono(Type.at(Some(pos),int_type)));
   (Names.Id("a2"), Scheme.mono(Type.at(Some(pos),string_type)));
  ],
)
var mod_Pervasives = Module.make(
  [],
  [(Names.Op("+"),
    Scheme.mono(
      Type.at(Some(pos),Type.Fun(
        Type.at(Some(pos),int_type),
        Type.at(Some(pos),Type.Fun(
          Type.at(Some(pos),int_type),Type.at(Some(pos),int_type)))))));
  ],
)
var inf = {
  mods = [
    ("A", mod_A);
    ("Pervasives", mod_Pervasives);
  ];
  opens = [("Pervasives", [])];
  asp = [(Names.Id("ans"), Scheme.mono(Type.at(Some(pos),int_type)))];
  let_level = 0;
}
var shower = Type.create_shower(0)
var int_expr = Expr.at(pos, Expr.Con(Literal.Int(123)))
var string_expr = Expr.at(pos, Expr.Con(Literal.String("abc")))
var char_expr = Expr.at(pos, Expr.Con(Literal.Char("x")))
assert(Type.show(shower, infer_expr(inf, int_expr)) = "int")
assert(Type.show(shower, infer_expr(inf, string_expr)) = "string")
assert(Type.show(shower, infer_expr(inf, char_expr)) = "char")
var ans = Expr.at(pos, Expr.Var([], Names.Id("ans")))
var _A_a2 = Expr.at(pos, Expr.Var(["A"], Names.Id("a2")))
var _A_B_b1 = Expr.at(pos, Expr.Var(["A"; "B"], Names.Id("b1")))
assert(Type.show(shower, infer_expr(inf, ans)) = "int")
assert(Type.show(shower, infer_expr(inf, _A_a2)) = "string")
assert(Type.show(shower, infer_expr(inf, _A_B_b1)) = "char")
var app_expr = Expr.at(pos, Expr.App(int_expr, string_expr))
try:
  ignore(infer_expr(inf, app_expr))
with:
  case Failure(got):
    var req = sprintf(
      "%s%s%s%s%s%s%s%s",
      "<assertion>:1:0: error: invalid application\n",
      "function type: int\n",
      "argument type: string\n",
      "<assertion>\n",
      "^\n",
      "<assertion>:1:0: 'int' of function type\n",
      "<assertion>\n",
      "^\n",
    )
    assert(got = req)
var add = Expr.at(pos, Expr.Var([], Names.Op("+")))
var add_int = Expr.at(pos, Expr.App(add, int_expr))
var add_int_int = Expr.at(pos,Expr.App(add_int, int_expr))
assert(Type.show(shower, infer_expr(inf, add)) = "(int -> (int -> int))")
assert(Type.show(shower, infer_expr(inf, add_int)) = "(int -> int)")
assert(Type.show(shower, infer_expr(inf, add_int_int)) = "int")
